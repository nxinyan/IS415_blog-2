---
title: "Take Home Exercise 2"
description: |
  In this Take-home Exericse, (A) an investigation will be conducted to see if the distribution of Airbnb listings is affected by location factors and (B) analyse the impact of COVID-19 on Airbnb business in Singapore by comparing Airbnb listings data on June 2019 and June 2021.
author:
  - name: Ngah Xin Yan
    url: https://github.com/nxinyan/
date: 09-26-2021
output:
  distill::distill_article:
    self_contained: false
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, 
                      eval = TRUE,
                      message = FALSE,
                      warning = FALSE,
                      fig.retina = 3)
```

## Overview

The 'sharing economy' has seen unparalleled growth in terms of number of users, making it possible for new methods of economic and social interactions. 

Airbnb, once belonging to the sharing economy, has expanded into many cities across many countries and successfully transitioned into profitability, showing the valid validity of sharing economy within the global market.

Singapore has yet to legalise short-term rentals offered by platforms such as Airbnb. However, there are datasets for Airbnb listing in Singapore.

## Objective
### Section A: Airbnb Distribution

To investigate if the distribution of Airbnb listings are affected by location factors 

### Section B: Impact of COVID-19

To analyse the impact of COVID-19 on Airbnb business in Singapore by comparing Airbnb listings data on June 2019 and June 2021.

## Data Used

- **Airbnb Listing (June 2019)**: Singapore's Airbnb listing for 2019 (csv file) from [Inside Airbnb](http://insideairbnb.com/get-the-data.html)
- **Airbnb Listing (July 2021)**: Singapore's Airbnb listing for 2021 (csv file) from [Inside Airbnb](http://insideairbnb.com/get-the-data.html)
- **Hotels**: Listing of hotels in Singapore (csv file) from [OneMap API](https://cran.r-project.org/web/packages/onemapsgapi/index.html)
- **Tourism**: List of tourist attraction in Singapore (csv file) from [OneMap API](https://cran.r-project.org/web/packages/onemapsgapi/index.html)
- **CostalOutline**: National Boundary of Singapore (shp file) from [data.gov.sg](https://data.gov.sg/dataset/national-map-polygon)
- **MP14_SUBZONE_WEB_PL**: URA 2014 Master Plan Planning Subzone Boundary Data (shp file) from [data.gov.sg](https://data.gov.sg/dataset/master-plan-2014-subzone-boundary-web)
- **MRTLRTStnPtt**: All MRT and LRT stations in Singapore (shp file) from [LTA Datamall](https://datamall.lta.gov.sg/content/datamall/en/search_datasets.html?searchText=mrt)


## Installing and Loading the R packages

- **sf**: used to import, manage and process vector-based geospatial data in R.

- [**spatstat**](https://spatstat.org/): for point pattern analysis.

- [**raster**](https://cran.r-project.org/web/packages/raster/): reads, writes, manipulates, analyses and model of gridded spatial data.

- [**maptools**](https://cran.r-project.org/web/packages/maptools/index.html): provides a set of tools for manipulating geographic data.

- [**tmap**](https://cran.r-project.org/web/packages/tmap/index.html): to plot cartographic quality static point patterns maps or interactive maps by using leaflet API.

- **tidyverse**: to perform data science tasks such as importing, wrangling and visualising data

```{r}
packages = c('maptools', 'sf', 'raster','spatstat', 'tmap','tidyverse','rgdal','ggplot2', 'ggthemes', 'plotly')
for (p in packages){
  if(!require(p, character.only = T)){
    install.packages(p)
  }
  library(p,character.only = T)
}
```

## Data Extraction, Wrangling and Integration
### Importing Geospatial Data

Importing the following geospatial dataset into R by using *st_read()* of **sf** package

**`MP14_SUBZONE_WEB_PL`**

```{r}
mpsz = st_read(dsn = "data/geospatial", 
                  layer = "MP14_SUBZONE_WEB_PL")
```

**`CostalOutline`**

```{r}
sg <- st_read(dsn = "data/geospatial", layer="CostalOutline")
```

**`MRTLRTStnPtt`**

```{r}
mrtlrt <- st_read(dsn = "data/geospatial", layer="MRTLRTStnPtt")
```
The projected CRS of all the data frames are SVY21, which is relevant for analysis in Singapore. However, the EPSG code should be checked as when importing geospatial data into R, the coordinate system of the source data can go missing or be wrongly assigned.

### Assigning EPSG code to a simple feature data frame

```{r}
st_crs(mpsz)
```

```{r}
st_crs(sg)
```

```{r}
st_crs(mrtlrt)
```

All data frames indicated that the EPSG code is 9001 which is wrong. The EPSG code for SVY21 is 3414.

*st_crs(sg)* of **sf** package will be used to assign the correct EPSG code to all data frames.

```{r}
mpsz_sf <- st_transform(mpsz, 3414)
```

```{r}
sg_sf <- st_transform(sg, 3414)
```

```{r}
mrtlrt_sf <- st_transform(mrtlrt, 3414)
```

Checking CRS again

```{r}
st_crs(mpsz_sf)
```

```{r}
st_crs(sg_sf)
```

```{r}
st_crs(mrtlrt_sf)
```

All dataframes has the EPSG code of 3414 now.

### Importing Aspatial Data 

Importing the following aspatial dataset into R dataframe by using *read_csv()* function of **readr** package in **tidyverse**:

```{r}
airbnb_june2019 <- read_csv("data/aspatial/airbnb_june2019.csv")
airbnb_july2021 <- read_csv("data/aspatial/airbnb_july2021.csv")
hotels <- read_csv("data/aspatial/hotels.csv")
tourism <- read_csv("data/aspatial/tourism.csv")
```

Use ***glimpse()*** to learn more about the attribute information in the data frame.

```{r}
glimpse(airbnb_june2019)
```

```{r}
glimpse(airbnb_july2021)
```

```{r}
glimpse(hotels)
```

```{r}
glimpse(tourism)
```

***glimpse()*** report reveals the data type of each fields. 

The ***latitude*** and ***longitude*** column are for the coordinates, which are in decimal degree format. There are also some dataset which uses ***LATITUDE***/***LONGITUDE*** and ***longitude***/***Lng*** columns instead, but it still shows the coordinates in decimal degree format. It is good to assume that the data is in **WGS84** . It has to be assigned to the correct coordinate system to match the geospatial data above.  

### Pre-Processing of Data 
**Dealing with Missing Values**

Using the ***is.na()*** function, check for missing value in the ***latitude***/***Lat*** and ***longitude***/***Lng*** column.

```{r}
any(is.na(airbnb_june2019$latitude))
any(is.na(airbnb_june2019$longitude))
```

```{r}
any(is.na(airbnb_july2021$latitude))
any(is.na(airbnb_july2021$longitude))
```

```{r}
any(is.na(hotels$Lat))
any(is.na(hotels$Lng))
```

```{r}
any(is.na(tourism$LATITUDE))
any(is.na(tourism$LONGTITUDE))
```

```{r}
any(is.na(tourism$Lat))
any(is.na(tourism$Lng))
```

There are no NA values for ***airbnb_june2019***, ***airbnb_july2021 ***, ***hotels *** dataset for Latitude and Longitude. However, for  ***tourism ***, there is missing value in its  ***LATITUDE*** and  ***Longtitude*** column. However, there is no missing value in its ***Lat*** and ***Lng*** column. Thus, the ***Lat*** and ***Lng*** column will be used to create the simple data frame instead.

```{r}
tourism <- tourism %>%
            drop_na("LATITUDE")

tourism <- tourism %>%
            drop_na("LONGTITUDE")
```

### Transforming the projection of coordinate system

All the data will be converted into simple feature data frame using ***st_as_sf()*** function. For the coords argument, ***longitude*** will be used as the x-coordinate and ***latitude*** will be the y-coordinate. WGS84 geographic coordinate system uses EPSG code 4326 but we have to match our geospatial data projected coordinate system. %<% is used to nest ***st_transform()*** trabsform the new simple feature data frame in SVY21 (EPSG: 3414) projected coordinates system. 

```{r}
airbnb_june2019_sf <- st_as_sf(airbnb_june2019, 
                          coords = c("longitude", 
                                     "latitude"), 
                          crs = 4326) %>%
  st_transform(crs=3414)
```

```{r}
airbnb_july2021_sf <- st_as_sf(airbnb_july2021, 
                          coords = c("longitude", 
                                     "latitude"), 
                          crs = 4326) %>%
  st_transform(crs=3414)
```

```{r}
hotels_sf <- st_as_sf(hotels, 
                          coords = c("Lng", 
                                     "Lat"), 
                          crs = 4326) %>%
  st_transform(crs=3414)
```

```{r}
tourism_sf <- st_as_sf(tourism, 
                          coords = c("LONGTITUDE", 
                                     "LATITUDE"), 
                          crs = 4326) %>%
  st_transform(crs=3414)
```

Checking CRS again

```{r}
st_crs(airbnb_june2019_sf)
st_crs(airbnb_july2021_sf)
st_crs(hotels_sf)
st_crs(tourism_sf)
```

All the data has successfully been changed to EPSG 3414.

## Geospatial Data Wrangling

Both geospatial and aspatial data will be converted from simple feature frame to sp's Spatial* class.

### Converting sf data frames to sp’s Spatial* class

*as_Spatial()* is used to convert the all the geospatial data from simple feature data frame to sp’s Spatial* class.

```{r}
mpsz <- as_Spatial(mpsz_sf)
sg <- as_Spatial(sg_sf)
mrtlrt <-as_Spatial(mrtlrt_sf)
                    
airbnb_june2019 <- as_Spatial(airbnb_june2019_sf)
airbnb_july2021 <- as_Spatial(airbnb_july2021_sf)
hotels <- as_Spatial(hotels_sf)
tourism <- as_Spatial(tourism_sf)                    
```

Checking all the Spatial* class

```{r}
mpsz
```

```{r}
sg
```

```{r}
mrtlrt
```

```{r}
airbnb_june2019
```

```{r}
airbnb_july2021
```

```{r}
hotels
```

```{r}
tourism
```

All the geospatial data have been converted to their respective sp's Spatial* classes.

### Converting the Spatial* class into generic sp format

It is mandatory for the analytical data to be in ***ppp*** object form to use **spatstat**. Since there is no direct way to convert a Spatial* classes into ***ppp*** object, ***Spatial classes**** needs to be converted into ***Spatial*** object first.

```{r}
mpsz_sp <- as(mpsz, "SpatialPolygons")
sg_sp <- as(sg, "SpatialPolygons")
mrtlrt_sp <- as(mrtlrt, "SpatialPoints")

airbnb_june2019_sp <- as(airbnb_june2019, "SpatialPoints")
airbnb_july2021_sp <- as(airbnb_july2021, "SpatialPoints")
hotels_sp <- as(hotels, "SpatialPoints")
tourism_sp <- as(tourism, "SpatialPoints")
```

### Converting the generic sp format into spatstat’s ppp format

*as.ppp()* function of **spatspat** is used to convert the spatial data into **spatstat**'s ***ppp*** object format.

```{r}
mrtlrt_ppp <- as(mrtlrt_sp, "ppp")
airbnb_june2019_ppp <- as(airbnb_june2019_sp, "ppp")
airbnb_july2021_ppp <- as(airbnb_july2021_sp, "ppp")
hotels_ppp <- as(hotels_sp, "ppp")
tourism_ppp <- as(tourism_sp, "ppp")
```

Taking a quick look at the summary statistics of the newly created **ppp** object with *summary()* 

```{r}
summary(mrtlrt_ppp)
```

```{r}
summary(airbnb_june2019_ppp)
```

```{r}
summary(airbnb_july2021_ppp)
```

```{r}
summary(hotels_ppp)
```

```{r}
summary(tourism_ppp)
```

From the summary above, there are 3 ppp objects that contains duplicated points: airbnb_june2019_ppp, airbnb_july2021_ppp, hotels_ppp and tourism_ppp

### Handling Duplicated Points

Checking for duplication in ***ppp*** object and the number of duplicated points

```{r}
any(duplicated(mrtlrt_ppp))
sum(multiplicity(mrtlrt_ppp) > 1)
```

There are no duplicated points in mrtlrt_ppp. 

```{r}
any(duplicated(airbnb_june2019_ppp))
sum(multiplicity(airbnb_june2019_ppp) > 1)
```

There are 6 duplicated points in *airbnb_june2019_ppp* as shown above.

```{r}
any(duplicated(airbnb_july2021_ppp))
sum(multiplicity(airbnb_july2021_ppp) > 1)
```

There are 224 duplicated points in *airbnb_july2021_ppp* as shown above.

```{r}
any(duplicated(hotels_ppp))
sum(multiplicity(hotels_ppp) > 1)
```

There are 10 duplicated points in *hotels_ppp* as shown above.

```{r}
any(duplicated(tourism_ppp))
sum(multiplicity(tourism_ppp) > 1)
```

There are 7 duplicated points in *tourism_ppp* as shown above.

### Jittering

To overcome the problem of duplicates, *jittering* will be used. Jittering adds a small perturbation to the duplicate points so that they do not occupy the exact same space.

```{r}
airbnb_june2019_ppp_jit <- rjitter(airbnb_june2019_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
airbnb_july2021_ppp_jit <- rjitter(airbnb_july2021_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
hotels_ppp_jit <- rjitter(hotels_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

```{r}
tourism_ppp_jit <- rjitter(tourism_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

Check for duplicated points again.

```{r}
any(duplicated(airbnb_june2019_ppp_jit))
```

```{r}
any(duplicated(airbnb_july2021_ppp_jit))
```

```{r}
any(duplicated(hotels_ppp_jit))
```

```{r}
any(duplicated(tourism_ppp_jit))
```

There are no duplicated points after applying *jittering*.

### Creation of *owin* object

While analysing spatial point patterns, it is good to confine the analysis within a certain geographical area, which in this case will be Singapore boundary. ***owin*** in **spatstat** is specially designed to represent the polygonal region.

```{r}
sg_owin <- as(sg_sp, "owin")
```

Displaying the output object with the use of *plot()* function.

```{r}
plot(sg_owin)
```

Checking the summary of owin

```{r}
summary(sg_owin)
```

### Combining Point Events Object and owin object

Extracting the relevant events located within Singapore.

```{r}
mrtlrt_sg_ppp = mrtlrt_ppp[sg_owin]
airbnb_june2019_sg_ppp = airbnb_june2019_ppp_jit[sg_owin]
airbnb_july2021_sg_ppp = airbnb_july2021_ppp_jit[sg_owin]
hotels_sg_ppp = hotels_ppp_jit[sg_owin]
tourism_sg_ppp = tourism_ppp_jit[sg_owin]
```

Visualisation of ***ppp*** objects 

Using *plot()* function to visualise the ***ppp*** objects within Singapore's boundary

```{r fig.width=12, fig.height=8}
plot(mrtlrt_sg_ppp)
```

```{r fig.width=12, fig.height=8}
plot(airbnb_june2019_sg_ppp)
```

```{r fig.width=12, fig.height=8}
plot(airbnb_july2021_sg_ppp)
```

```{r fig.width=12, fig.height=8}
plot(hotels_sg_ppp)
```

```{r fig.width=12, fig.height=8}
plot(tourism_sg_ppp)
```

# Section A: Airbnb Distribution in 2019

## Exploratory Spatial Data Analysis

- Derive kernel density maps of Airbnb listings, hotels, MRT services, and tourist attractions.

- Using appropriate tmap functions, display the kernel density maps on openstreetmap of Singapore. Describe the spatial patterns revealed by the kernel density maps. Highlight the advantage of kernel density map over point map.

### Airbnb Listing June 2019

#### **Computing kernel density estimation using automatic bandwidth selection method**

Computing kernel density using *density()* of **spatstat** using *bw.diggle()*, a automatic bandwidth selection method. The default smoothing kernel is *gaussian*.

There are other bandwidth selection method such as *bw.ppl()* but I chosen to use *bw.diggle()* as it can identify single tight cluster patterns among random noise.

```{r}
kde_airbnb_june2019_sg_bw <- density(airbnb_june2019_sg_ppp,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
plot(kde_airbnb_june2019_sg_bw)
```

After looking at the first graph, I realised the output value range is too small to comprehend. This is due to the default unit of measurement of svy21 in meter. Thus, it was computed in “number of points per square meter”.

#### **Rescalling KDE values to km(kilometer)**

```{r}
airbnb_june2019_sg_ppp_km <- rescale(airbnb_june2019_sg_ppp, 1000, 'km')
```

Now, the code can be re-run to get a better comprehension.

```{r}
kde_airbnb_june2019_sg_bw <- density(airbnb_june2019_sg_ppp_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

#### **Plotting of Kernel Density Estimation Maps**

```{r fig.width=12, fig.height=8}
par(mfrow=c(1,2))
plot(kde_airbnb_june2019_sg_bw,  main = "KDE Map")
plot(airbnb_june2019_sg_ppp_km,  main = "Point Map")
```
Analysis: It can be seen that the Airbnb listings are mostly situated in the south-east region close to the central area. This can seen by the higher density in the map shown by the pink spots in the kernel density estimation map

Advantage of using kernel density map: Using the KDE map, the different shades of colour helps to visualise the density better as compared to point map. Point map only can only show the location of one place at the time, if too clustered together, it will just appear as a black patch and we would not be able to tell anything from it.

#### Converting KDE output into grid object.

Converting it so that it is suitable for mapping purposes.

```{r}
gridded_kde_airbnb_june2019_sg_bw <- as.SpatialGridDataFrame.im(kde_airbnb_june2019_sg_bw)
spplot(gridded_kde_airbnb_june2019_sg_bw)
```

The density map using grid shows a better visualisation of the listings as it is more visible to see those that are less clustered together as shown with the lighter shade of blue.

```{r}
kde_airbnb_june2019_sg_bw_m <- density(airbnb_june2019_sg_ppp,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
gridded_kde_airbnb_june2019_sg_bw_m <- as.SpatialGridDataFrame.im(kde_airbnb_june2019_sg_bw_m)
```


#### **CONVERTING GRIDDED OUTPUT INTO RASTER**

Converting the gridded kernal density objects into RasterLayer object by using raster() of **raster** package.

```{r}
kde_airbnb_june2019_bw_raster <- raster(gridded_kde_airbnb_june2019_sg_bw_m)
kde_airbnb_june2019_bw_raster
```
The crs property is NA as shown above.

#### **ASSIGNING PROJECTION SYSTEMS** display the kernel density maps on openstreetmap of Singapore

Assigning the CRS information on kde_airbnb_june2019_bw_raster Raster Layer

```{r}
projection(kde_airbnb_june2019_bw_raster) <- CRS("+init=EPSG:3414")
kde_airbnb_june2019_bw_raster
```

The CRS property is now available.

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")
tm_basemap("OpenStreetMap") +
tm_shape(kde_airbnb_june2019_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)
```

Analysis: From the interactive map above, Airbnb can be seen in areas around Geylang which has a highest density of 0.00015 to 0.00020 units per square meter with the darkest shade of purple. Following that will be areas around Chinatown and Clarke Quay with a higher density of 0.00010 to 0.00015 units per square meter shown with the darker shade of purple.


### Hotels

#### **Rescalling KDE values to km(kilometer)**

```{r}
hotels_sg_ppp_km <- rescale(hotels_sg_ppp, 1000, 'km')
```

```{r}
kde_hotels_sg_bw <- density(hotels_sg_ppp_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

#### **Plotting of Kernel Density Estimation Maps**

```{r fig.width=12, fig.height=8}
par(mfrow=c(1,2))
plot(kde_hotels_sg_bw,  main = "KDE Map")
plot(hotels_sg_ppp_km,  main = "Point Map")
```

#### Converting KDE output into grid object.

Converting it so that it is suitable for mapping purposes.

```{r}
gridded_kde_hotels_sg_bw <- as.SpatialGridDataFrame.im(kde_hotels_sg_bw)
spplot(gridded_kde_hotels_sg_bw)
```

The density map using grid shows a better visualisation of the listings as it is more visible to see those that are less clustered together as shown with the lighter shade of blue.

```{r}
kde_hotels_sg_bw_m <- density(hotels_sg_ppp,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
gridded_kde_hotels_sg_bw_m <- as.SpatialGridDataFrame.im(kde_hotels_sg_bw_m)
```

#### **CONVERTING GRIDDED OUTPUT INTO RASTER**

Converting the gridded kernal density objects into RasterLayer object by using raster() of **raster** package.

```{r}
kde_hotels_bw_raster <- raster(gridded_kde_hotels_sg_bw_m)
kde_hotels_bw_raster
```
The crs property is NA as shown above.

#### **ASSIGNING PROJECTION SYSTEMS** display the kernel density maps on openstreetmap of Singapore

Assigning the CRS information on kde_airbnb_june2019_bw_raster Raster Layer

```{r}
projection(kde_hotels_bw_raster) <- CRS("+init=EPSG:3414")
kde_hotels_bw_raster
```

The CRS property is now available.

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")
tm_basemap("OpenStreetMap") +
tm_shape(kde_hotels_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)
```

Analysis: From the interactive map above, hotels can be seen that areas around Geylang and Clarke Quay has a highest density of 0.00015 to 0.00020 units per square meter. Following that will be areas around Lavender and Rocher with a higher density of hotel ranging from 0.00010 to 0.00015 units per square meter.


### MRT and LRT

#### **Rescalling KDE values to km(kilometer)**

```{r}
mrtlrt_sg_ppp_km <- rescale(mrtlrt_sg_ppp, 1000, 'km')
```

```{r}
kde_mrtlrt_sg_bw <- density(mrtlrt_sg_ppp_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

#### **Plotting of Kernel Density Estimation Maps**

```{r fig.width=12, fig.height=8}
par(mfrow=c(1,2))
plot(kde_mrtlrt_sg_bw,  main = "KDE Map")
plot(mrtlrt_sg_ppp_km,  main = "Point Map")
```

#### Converting KDE output into grid object.

Converting it so that it is suitable for mapping purposes.

```{r}
gridded_kde_mrtlrt_sg_bw <- as.SpatialGridDataFrame.im(kde_mrtlrt_sg_bw)
spplot(gridded_kde_mrtlrt_sg_bw)
```

The density map using grid shows a better visualisation of the listings as it is more visible to see those that are less clustered together as shown with the lighter shade of blue.

```{r}
kde_mrtlrt_sg_bw_m <- density(mrtlrt_sg_ppp,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
gridded_kde_mrtlrt_sg_bw_m <- as.SpatialGridDataFrame.im(kde_mrtlrt_sg_bw_m)
```

#### **CONVERTING GRIDDED OUTPUT INTO RASTER**

Converting the gridded kernal density objects into RasterLayer object by using raster() of **raster** package.

```{r}
kde_mrtlrt_bw_raster <- raster(gridded_kde_mrtlrt_sg_bw_m)
kde_mrtlrt_bw_raster
```
The crs property is NA as shown above.

#### **ASSIGNING PROJECTION SYSTEMS** display the kernel density maps on openstreetmap of Singapore

Assigning the CRS information on kde_airbnb_june2019_bw_raster Raster Layer

```{r}
projection(kde_mrtlrt_bw_raster) <- CRS("+init=EPSG:3414")
kde_mrtlrt_bw_raster
```

The CRS property is now available.

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")
tm_basemap("OpenStreetMap") +
tm_shape(kde_mrtlrt_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)  
```

Analysis: From the interactive map above, we can see that North-west, North-east and South-Central area has a higher density of MRT and LRT station, ranging 0.0000020 to 0.0000030.


### Tourist Attractions

#### **Rescalling KDE values to km(kilometer)**

```{r}
tourism_sg_ppp_km <- rescale(tourism_sg_ppp, 1000, 'km')
```

```{r}
kde_tourism_sg_bw <- density(tourism_sg_ppp_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

#### **Plotting of Kernel Density Estimation Maps**

```{r fig.width=12, fig.height=8}
par(mfrow=c(1,2))
plot(kde_tourism_sg_bw,  main = "KDE Map")
plot(tourism_sg_ppp_km,  main = "Point Map")
```

#### Converting KDE output into grid object.

Converting it so that it is suitable for mapping purposes.

```{r}
gridded_kde_tourism_sg_bw <- as.SpatialGridDataFrame.im(kde_tourism_sg_bw)
spplot(gridded_kde_tourism_sg_bw)
```

The density map using grid shows a better visualisation of the listings as it is more visible to see those that are less clustered together as shown with the lighter shade of blue.

```{r}
kde_tourism_sg_bw_m <- density(tourism_sg_ppp,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
gridded_kde_tourism_sg_bw_m <- as.SpatialGridDataFrame.im(kde_tourism_sg_bw_m)
```

#### **CONVERTING GRIDDED OUTPUT INTO RASTER**

Converting the gridded kernal density objects into RasterLayer object by using raster() of **raster** package.

```{r}
kde_tourism_bw_raster <- raster(gridded_kde_tourism_sg_bw_m)
kde_tourism_bw_raster
```
The crs property is NA as shown above.

#### **ASSIGNING PROJECTION SYSTEMS** display the kernel density maps on openstreetmap of Singapore

Assigning the CRS information on kde_airbnb_june2019_bw_raster Raster Layer

```{r}
projection(kde_tourism_bw_raster) <- CRS("+init=EPSG:3414")
kde_tourism_bw_raster
```

The CRS property is now available.

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")
tm_basemap("OpenStreetMap") +
tm_shape(kde_tourism_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)  
```

Analysis: There is high concentration of tourist attractions in the south-central, with a high density of 0.000015 to 0.000020.

### Comparing Spatial Point Patterns using KDE

The areas we will look into will be Anson, Bugis, Chinatown and Geylang as there are higher density of Airbnb

#### **EXTRACTING STUDY AREA**

```{r}
downtown = mpsz[mpsz@data$PLN_AREA_N == "DOWNTOWN CORE",] #for Anson
rochor = mpsz[mpsz@data$PLN_AREA_N == "ROCHOR",] # for Bugis
outram = mpsz[mpsz@data$PLN_AREA_N == "OUTRAM",] # for Chinatown
geylang = mpsz[mpsz@data$PLN_AREA_N == "GEYLANG",] # for Geylang

```

Plotting target planning areas

```{r}
par(mfrow=c(2,2))
plot(downtown, main = "Downtown")
plot(rochor, main = "Rochor")
plot(outram, main = "Outram")
plot(geylang, main = "Geylang")
```

#### **CONVERTING THE SPATIAL POINT DATA FRAME INTO GENERIC SP FORMAT**

Converting SpatialPolygonsDataFrame layers into generic spatialpolygons layers.

```{r}
downtown_sp = as(downtown, "SpatialPolygons")
rochor_sp = as(rochor, "SpatialPolygons")
outram_sp = as(outram, "SpatialPolygons")
geylang_sp = as(geylang, "SpatialPolygons")
```

#### **CREATING OWIN OBJECT**

Converting SpatialPolygons objects into owin objects that is required by **spatstat**

```{r}
downtown_owin = as(downtown_sp, "owin")
rochor_owin = as(rochor_sp, "owin")
outram_owin = as(outram_sp, "owin")
geylang_owin = as(geylang_sp, "owin")
```

#### **COMBINING AIRBNB JUNE 2019, HOTELS, MRTLRT, TOURISM POINTS AND THE STUDY AREA**

```{r}
airbnb_june2019_downtown_ppp = airbnb_june2019_ppp_jit[downtown_owin]
airbnb_june2019_rochor_ppp = airbnb_june2019_ppp_jit[rochor_owin]
airbnb_june2019_outram_ppp = airbnb_june2019_ppp_jit[outram_owin]
airbnb_june2019_geylang_ppp = airbnb_june2019_ppp_jit[geylang_owin]

hotels_downtown_ppp = hotels_ppp_jit[downtown_owin]
hotels_rochor_ppp = hotels_ppp_jit[rochor_owin]
hotels_outram_ppp = hotels_ppp_jit[outram_owin]
hotels_geylang_ppp = hotels_ppp_jit[geylang_owin]

mrtlrt_downtown_ppp = mrtlrt_ppp[downtown_owin]
mrtlrt_rochor_ppp = mrtlrt_ppp[rochor_owin]
mrtlrt_outram_ppp = mrtlrt_ppp[outram_owin]
mrtlrt_geylang_ppp = mrtlrt_ppp[geylang_owin]

tourism_downtown_ppp = tourism_ppp_jit[downtown_owin]
tourism_rochor_ppp = tourism_ppp_jit[rochor_owin]
tourism_outram_ppp = tourism_ppp_jit[outram_owin]
tourism_geylang_ppp = tourism_ppp_jit[geylang_owin]
```

Next, rescale() function is used to trasnform the unit of measurement from metre to kilometre

```{r}
airbnb_june2019_downtown_ppp_km = rescale(airbnb_june2019_downtown_ppp, 1000, "km")
airbnb_june2019_rochor_ppp_km = rescale(airbnb_june2019_rochor_ppp, 1000, "km")
airbnb_june2019_outram_ppp_km = rescale(airbnb_june2019_outram_ppp, 1000, "km")
airbnb_june2019_geylang_ppp_km = rescale(airbnb_june2019_geylang_ppp, 1000, "km")

hotels_downtown_ppp_km = rescale(hotels_downtown_ppp, 1000, "km")
hotels_rochor_ppp_km = rescale(hotels_rochor_ppp, 1000, "km")
hotels_outram_ppp_km = rescale(hotels_outram_ppp, 1000, "km")
hotels_geylang_ppp_km = rescale(hotels_geylang_ppp, 1000, "km")

mrtlrt_downtown_ppp_km = rescale(mrtlrt_downtown_ppp, 1000, "km")
mrtlrt_rochor_ppp_km = rescale(mrtlrt_rochor_ppp, 1000, "km")
mrtlrt_outram_ppp_km = rescale(mrtlrt_outram_ppp, 1000, "km")
mrtlrt_geylang_ppp_km = rescale(mrtlrt_geylang_ppp, 1000, "km")

tourism_downtown_ppp_km = rescale(tourism_downtown_ppp, 1000, "km")
tourism_rochor_ppp_km = rescale(tourism_rochor_ppp, 1000, "km")
tourism_outram_ppp_km = rescale(tourism_outram_ppp, 1000, "km")
tourism_geylang_ppp_km = rescale(tourism_geylang_ppp, 1000, "km")
```

#### **Airbnb June 2019** 

COMPUTING IDE

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,2))
plot(density(airbnb_june2019_downtown_ppp_km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Downtown")
plot(density(airbnb_june2019_rochor_ppp_km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Rochor")
plot(density(airbnb_june2019_outram_ppp_km, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Outram")
plot(density(airbnb_june2019_geylang_ppp, 
             sigma=bw.diggle, 
             edge=TRUE, 
             kernel="gaussian"),
     main="Geylang")
```

#### **Are Airbnb listings are affected by location factors?**

**DOWNTOWN**

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,2))
plot(airbnb_june2019_downtown_ppp_km, main = "Airbnb")
plot(hotels_downtown_ppp_km, main = "Hotel")
plot(mrtlrt_downtown_ppp_km, main = "MRT and LRT")
plot(tourism_downtown_ppp_km, main = "Tourist Attraction")
```

Analysis: Even though there are many hotels in the vicinity, there are more Airbnb as compared to hotels. It could be due to easy accessibility to many MRT stations and tourist attractions in the vicinity.

**ROCHOR**

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,2))
plot(airbnb_june2019_rochor_ppp_km, main = "Airbnb")
plot(hotels_rochor_ppp_km, main = "Hotel")
plot(mrtlrt_rochor_ppp_km, main = "MRT and LRT")
plot(tourism_rochor_ppp_km, main = "Tourist Attraction")
```

Analysis: Even though there are many hotels in the Rochor, there are also many Airbnb as compared to hotels. It could be due to easy accessibility to many MRT stations nearby and tourist attractions in the vicinity.

**OUTRAM**

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,2))
plot(airbnb_june2019_outram_ppp_km, main = "Airbnb")
plot(hotels_outram_ppp_km, main = "Hotel")
plot(mrtlrt_outram_ppp_km, main = "MRT and LRT")
plot(tourism_outram_ppp_km, main = "Tourist Attraction")
```

Analysis: Even though there are many hotels in the Rochor, there is more Airbnb as compared to hotels. However, there is very little MRT station and some tourist attractions in the vicinity.

**GEYLANG**

```{r fig.width=8, fig.height=6}
par(mfrow=c(2,2))
plot(airbnb_june2019_geylang_ppp_km, main = "Airbnb")
plot(hotels_geylang_ppp_km, main = "Hotel")
plot(mrtlrt_geylang_ppp_km, main = "MRT and LRT")
plot(tourism_geylang_ppp_km, main = "Tourist Attraction")
```

Analysis: There are many Airbnb in this area, with very little hotels nearby. It is quite accessible to MRT Stations but there is only one tourist attraction in the vicinity.

Overall: Even though the numbers of hotel in thee vicinity is high, there are still many Airbnb listing in all the areas. Every location was very accessible to MRT stations except Outram, but it didnt affect the number of Airbnb in the area. The same goes for tourist attractions, except for Geylang which only have one tourist attraction, but it did not affect the number of Airbnb in the area as well.

## Second-order Spatial Point Patterns Analysis

- Formulate the null hypothesis and alternative hypothesis and select the confidence level.

- Perform the test by using appropriate Second order spatial point patterns analysis technique.

- With reference to the analysis results, draw statistical conclusions.

### Nearest Neighbour Analysis

Perform the Clark-Evans test of aggregation for a spatial point pattern by using *clarkevans.test()* of **statspat**.

The test hypotheses are:

Ho = The distribution of Airbnb listings are randomly distributed.

H1= The distribution of Airbnb listings are not randomly distributed.

The 95% confident interval will be used.

### Testing spatial point patterns using Clark and Evans Test

```{r}
clarkevans.test(airbnb_june2019_sg_ppp,
                correction="none",
                clipregion="sg_owin",
                alternative=c("clustered"),
                nsim=99)
```

Analysis: The distribution of Airbnb in Singapore is found to be clustered as the R = 0.36 is < 1. The null hypothesis is rejected as the p-value = 0.01 is smaller than 0.05.

#### Clark and Evans Test: Downtown

```{r}
clarkevans.test(airbnb_june2019_downtown_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

Analysis: The null hypothesis is rejected as the p-value = 0.002 is smaller than 0.05, showing that the Airbnb Listings in Downtown are not randomly distributed.

#### Clark and Evans Test: Rochor

```{r}
clarkevans.test(airbnb_june2019_rochor_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

Analysis: The null hypothesis is rejected as the p-value = 0.002 is smaller than 0.05, showing that the Airbnb Listings in Rochor are not randomly distributed.

#### Clark and Evans Test: Outram

```{r}
clarkevans.test(airbnb_june2019_outram_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

Analysis: The null hypothesis is rejected as the p-value = 0.002 is smaller than 0.05, showing that the Airbnb Listings in Outram are not randomly distributed.

#### Clark and Evans Test: Geylang

```{r}
clarkevans.test(airbnb_june2019_geylang_ppp,
                correction="none",
                clipregion=NULL,
                alternative=c("two.sided"),
                nsim=999)
```

Analysis: The null hypothesis is rejected as the p-value = 0.002 is smaller than 0.05, showing that the Airbnb Listings in Geylang are not randomly distributed.

Overall: ALl the areas shows that the Airbnb listing are not randomly distributed. AS Rochor and Outram has R value nearer to 1, we will focus on those 2 areas for further analysis.

### Analysing Spatial Point Process Using G-Function

Measures the distribution of the distances from an arbitrary event to its nearest event.

#### **Rochor**

COMPUTING G-FUNCTION ESTIMATION

The code chunk below is used to compute G-function using Gest() of spatat package.

```{r}
G_rochor = Gest(airbnb_june2019_rochor_ppp, correction = "border")
plot(G_rochor, xlim=c(0,150))
```

Analysis: Analysis: Airbnb in Rochor are found to be clustered as from the plot above, G(r) rises sharply at the start and slowly increases after it passes around 30.

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Airbnb Listing at Rochor are randomly distributed.

H1= The distribution of Airbnb Listing at Rochor are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

Monte Carlo test with G-fucntion

```{r}
G_rochor.csr <- envelope(airbnb_june2019_rochor_ppp, Gest, nsim = 999)
```

```{r}
plot(G_rochor.csr)
```

Analysis: The Airbnb in Rochor is clustered as G(r) observed is above G(r) theo, having a higher confidence. The null hypothesis is rejected at 99% confidence interval.

#### **outram**

COMPUTING G-FUNCTION ESTIMATION

The code chunk below is used to compute G-function using Gest() of spatat package.

```{r}
G_outram = Gest(airbnb_june2019_outram_ppp, correction = "border")
plot(G_outram, xlim=c(0,150))
```

Analysis: Airbnb in Outram are found to be clustered as from the plot above, G(r) rises sharply at the start and slowly increases after it passes around 25.

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Airbnb Listing at Outram are randomly distributed.

H1= The distribution of Airbnb Listing at Outram are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

Monte Carlo test with G-fucntion

```{r}
G_outram.csr <- envelope(airbnb_june2019_outram_ppp, Gest, nsim = 999)
```

```{r}
plot(G_outram.csr)
```

Analysis: The Airbnb in Outram is clustered as G(r) observed is above G(r) theo, having a higher confidence. The null hypothesis is rejected at 99% confidence interval.

### Analysing Spatial Point Process Using F-Function

The F function estimates the empty space function F(r) or its hazard rate h(r) from a point pattern in a window of arbitrary shape.

#### **Rochor**

COMPUTING F-FUNCTION ESTIMATION


The code chunk below is used to compute F-function using Fest() of spatat package.

```{r}
F_rochor = Fest(airbnb_june2019_rochor_ppp)
plot(F_rochor)
```

Analysis: Analysis: Airbnb in Rochor are found to be clustered as from the plot above, F(r) rises gradually over time.

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Airbnb Listing at Rochor are randomly distributed.

H1= The distribution of Airbnb Listing at Rochor are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

Monte Carlo test with F-function

```{r}
F_rochor.csr <- envelope(airbnb_june2019_rochor_ppp, Fest, nsim = 999)
```

```{r}
plot(F_rochor.csr)
```

Analysis: The Airbnb in Rochor is clustered as F(r) observed is below F(r) theo, having a lower confidence. The null hypothesis is rejected at 99% confidence interval.


#### **Outram**

COMPUTING F-FUNCTION ESTIMATION


The code chunk below is used to compute F-function using Fest() of spatat package.

```{r}
F_outram = Fest(airbnb_june2019_outram_ppp)
plot(F_outram)
```

Analysis: Analysis: Airbnb in Rochor are found to be clustered as from the plot above, F(r) rises gradually over time.

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Airbnb Listing at Outram are randomly distributed.

H1= The distribution of Airbnb Listing at Outram are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

Monte Carlo test with F-function

```{r}
F_outram.csr <- envelope(airbnb_june2019_outram_ppp, Fest, nsim = 999)
```

```{r}
plot(F_outram.csr)
```

Analysis: The Airbnb in Outram is clustered as F(r) observed is below F(r) theo, having a lower confidence. The null hypothesis is rejected at 99% confidence interval.

### Analysing Spatial Point Process Using L-Function

To compute L-function estimation by using Lest() of spatstat package.

#### **Rochor**

COMPUTING L-FUNCTION ESTIMATION


The code chunk below is used to compute L-function using Lest() of spatat package.

```{r}
L_rochor = Lest(airbnb_june2019_rochor_ppp, correction = "Ripley")
plot(L_rochor, . -r ~ r, ylab= "L(r)", xlab = "r")
```

Analysis: Airbnb in Rochor shows L(r) above 0, thus it is likely to be clusrered.

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Airbnb Listing at Rochor are randomly distributed.

H1= The distribution of Airbnb Listing at Rochor are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
L_rochor.csr <- envelope(airbnb_june2019_rochor_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_rochor.csr, . - r ~ r, xlab="r", ylab="L(r)")
```

Analysis: The Airbnb in Rochor is clustered as L(r) observed is below L(r) theo, having a higher confidence. The null hypothesis is rejected at 99% confidence interval.

#### **Outram**

COMPUTING L-FUNCTION ESTIMATION


The code chunk below is used to compute L-function using Lest() of spatat package.

```{r}
L_outram = Lest(airbnb_june2019_outram_ppp, correction = "Ripley")
plot(L_outram, . -r ~ r, ylab= "L(r)", xlab = "r")
```

Analysis: Airbnb in Outram shows L(r) above 0, thus it is likely to be clustered.

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Airbnb Listing at Outram are randomly distributed.

H1= The distribution of Airbnb Listing at Outram are not randomly distributed.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
L_outram.csr <- envelope(airbnb_june2019_outram_ppp, Lest, nsim = 99, rank = 1, glocal=TRUE)
```

```{r}
plot(L_outram.csr, . - r ~ r, xlab="r", ylab="L(r)")
```

Analysis: The Airbnb in Outram is clustered as L(r) observed is below L(r) theo, having a higher confidence. The null hypothesis is rejected at 99% confidence interval.




# Section B: Impact of COVID-19

## Exploratory Spatial Data Analysis

- Derive kernel density maps of all Airbnb listings and Airbnb by room type as at June 2019 and June 2021

- Using appropriate tmap functions, display the kernel density maps on openstreetmap of Singapore,

- Describe the spatial patterns reveal by the kernel density maps.

### Airbnb Listing July 2021

#### **Rescalling KDE values to km(kilometer)**

```{r}
airbnb_july2021_sg_ppp_km <- rescale(airbnb_july2021_sg_ppp, 1000, 'km')
```

Now, the code can be re-run to get a better comprehension.

```{r}
kde_airbnb_july2021_sg_bw <- density(airbnb_july2021_sg_ppp_km,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

#### **Plotting of Kernel Density Estimation Maps**

```{r fig.width=12, fig.height=8}
plot(kde_airbnb_july2021_sg_bw)
```

#### Converting KDE output into grid object.

Converting it so that it is suitable for mapping purposes.

```{r}
gridded_kde_airbnb_july2021_sg_bw <- as.SpatialGridDataFrame.im(kde_airbnb_july2021_sg_bw)
spplot(gridded_kde_airbnb_july2021_sg_bw)
```

The density map using grid shows a better visualisation of the listings as it is more visible to see those that are less clustered together as shown with the lighter shade of blue.

```{r}
kde_airbnb_july2021_sg_bw_m <- density(airbnb_july2021_sg_ppp,
                                   sigma=bw.diggle,
                                   edge=TRUE,
                                   kernel="gaussian")
```

```{r}
gridded_kde_airbnb_july2021_sg_bw_m <- as.SpatialGridDataFrame.im(kde_airbnb_july2021_sg_bw_m)
```


#### **CONVERTING GRIDDED OUTPUT INTO RASTER**

Converting the gridded kernal density objects into RasterLayer object by using raster() of **raster** package.

```{r}
kde_airbnb_july2021_bw_raster <- raster(gridded_kde_airbnb_july2021_sg_bw_m)
kde_airbnb_july2021_bw_raster
```
The crs property is NA as shown above.

#### **ASSIGNING PROJECTION SYSTEMS** display the kernel density maps on openstreetmap of Singapore

Assigning the CRS information on kde_airbnb_june2019_bw_raster Raster Layer

```{r}
projection(kde_airbnb_july2021_bw_raster) <- CRS("+init=EPSG:3414")
kde_airbnb_july2021_bw_raster
```

The CRS property is now available.

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")
tm_basemap("OpenStreetMap") +
tm_shape(kde_airbnb_july2021_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)
```



#### Comparing between Airbnb Listing in June 2019 and July 2021

```{r}
par(mfrow=c(1,2))
plot(airbnb_june2019_sg_ppp_km, main = "Airbnb 2019")
plot(airbnb_july2021_sg_ppp_km, main = "Airbnb 2021")
```
Analysis: There is significant decrease in the number of Airbnb from 2019 to 2021.

### Airbnb Listing by room type for 2019 and 2021

#### Data Wrangling

Finding all category listed for room type

```{r}
unique(airbnb_june2019_sf$room_type)
```
There is private room, entire home/apt and shared room in Airbnb 2019.

```{r}
unique(airbnb_july2021_sf$room_type)
```

There is private room, entire home/apt, shared room and hotel room in Airbnb 2021.

#### Filtering each room type from SpatialPointsDataFrame

```{r}
airbnb_june2019_private = airbnb_june2019[airbnb_june2019@data$room_type == "Private room",]
airbnb_june2019_home = airbnb_june2019[airbnb_june2019@data$room_type == "Entire home/apt",]
airbnb_june2019_share = airbnb_june2019[airbnb_june2019@data$room_type == "Shared room",]
airbnb_july2021_private = airbnb_july2021[airbnb_july2021@data$room_type == "Private room",]
airbnb_july2021_home = airbnb_july2021[airbnb_july2021@data$room_type == "Entire home/apt",]
airbnb_july2021_share = airbnb_july2021[airbnb_july2021@data$room_type == "Shared room",]
airbnb_july2021_hotelroom = airbnb_july2021[airbnb_july2021@data$room_type == "Hotel room",]
```

#### Converting the Spatial* class into generic sp format

```{r}
airbnb_june2019_private_sp <- as(airbnb_june2019_private, "SpatialPoints")
airbnb_june2019_home_sp <- as(airbnb_june2019_home, "SpatialPoints")
airbnb_june2019_share_sp <- as(airbnb_june2019_share, "SpatialPoints")
airbnb_july2021_private_sp <- as(airbnb_july2021_private, "SpatialPoints")
airbnb_july2021_home_sp <- as(airbnb_july2021_home, "SpatialPoints")
airbnb_july2021_share_sp <- as(airbnb_july2021_share, "SpatialPoints")
airbnb_july2021_hotelroom_sp <- as(airbnb_july2021_hotelroom, "SpatialPoints")
```

#### Converting the generic sp format into spatstat’s ppp format

```{r}
airbnb_june2019_private_ppp <- as(airbnb_june2019_private_sp, "ppp")
airbnb_june2019_home_ppp <- as(airbnb_june2019_home_sp, "ppp")
airbnb_june2019_share_ppp <- as(airbnb_june2019_share_sp, "ppp")
airbnb_july2021_private_ppp <- as(airbnb_july2021_private, "ppp")
airbnb_july2021_home_ppp <- as(airbnb_july2021_home, "ppp")
airbnb_july2021_share_ppp <- as(airbnb_july2021_share, "ppp")
airbnb_july2021_hotelroom_ppp <- as(airbnb_july2021_hotelroom, "ppp")
```

### Checking for duplicates in each ppp's objects

```{r}
any(duplicated(airbnb_june2019_private_ppp))
```

```{r}
any(duplicated(airbnb_june2019_home_ppp))
```

```{r}
any(duplicated(airbnb_june2019_share_ppp))
```

```{r}
any(duplicated(airbnb_july2021_private_ppp))
```

```{r}
any(duplicated(airbnb_july2021_home_ppp))
```

```{r}
any(duplicated(airbnb_july2021_share_ppp))
```

```{r}
any(duplicated(airbnb_july2021_hotelroom_ppp))
```

Only airbnb_june2019_home_ppp and airbnb_june2019_share_ppp has duplicates.

#### Handling Duplicates

```{r}
airbnb_june2019_home_ppp_jit <- rjitter(airbnb_june2019_home_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
airbnb_june2019_share_ppp_jit <- rjitter(airbnb_june2019_share_ppp, 
                             retry=TRUE, 
                             nsim=1, 
                             drop=TRUE)
```

Checking for duplicates again

```{r}
any(duplicated(airbnb_june2019_home_ppp_jit))
```

```{r}
any(duplicated(airbnb_june2019_share_ppp_jit))
```

There are no more duplicated points.

#### Combining point events object and owin object

```{r}
airbnb_june2019_private_ppp_sg = airbnb_june2019_private_ppp[sg_owin]
airbnb_june2019_home_ppp_sg = airbnb_june2019_home_ppp_jit[sg_owin]
airbnb_june2019_share_ppp_sg = airbnb_june2019_share_ppp_jit[sg_owin]
airbnb_july2021_private_ppp_sg = airbnb_july2021_private_ppp[sg_owin]
airbnb_july2021_home_ppp_sg = airbnb_july2021_home_ppp[sg_owin]
airbnb_july2021_share_ppp_sg = airbnb_july2021_share_ppp[sg_owin]
airbnb_july2021_hotelroom_ppp_sg = airbnb_july2021_hotelroom_ppp[sg_owin]
```

#### Computing KDE

```{r}
kde_airbnb_june2019_private_bw <- density(airbnb_june2019_private_ppp_sg,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_airbnb_june2019_home_bw <- density(airbnb_june2019_home_ppp_sg,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_airbnb_june2019_share_bw <- density(airbnb_june2019_share_ppp_sg,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_airbnb_july2021_private_bw <- density(airbnb_july2021_private_ppp_sg,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_airbnb_july2021_home_bw <- density(airbnb_july2021_home_ppp_sg,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_airbnb_july2021_share_bw <- density(airbnb_july2021_share_ppp_sg,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
kde_airbnb_july2021_hotelroom_bw <- density(airbnb_july2021_hotelroom_ppp_sg,
                              sigma=bw.diggle,
                              edge=TRUE,
                            kernel="gaussian")
```

#### Converting KDE output into grid object

```{r}
gridded_kde_airbnb_june2019_private_bw <- as.SpatialGridDataFrame.im(kde_airbnb_june2019_private_bw)
gridded_kde_airbnb_june2019_home_bw <- as.SpatialGridDataFrame.im(kde_airbnb_june2019_home_bw)
gridded_kde_airbnb_june2019_share_bw <- as.SpatialGridDataFrame.im(kde_airbnb_june2019_share_bw)
gridded_kde_airbnb_july2021_private_bw <- as.SpatialGridDataFrame.im(kde_airbnb_july2021_private_bw)
gridded_kde_airbnb_july2021_home_bw <- as.SpatialGridDataFrame.im(kde_airbnb_july2021_home_bw)
gridded_kde_airbnb_july2021_share_bw <- as.SpatialGridDataFrame.im(kde_airbnb_july2021_share_bw)
gridded_kde_airbnb_july2021_hotelroom_bw <- as.SpatialGridDataFrame.im(kde_airbnb_july2021_hotelroom_bw)
```

#### Converting grid object into raster and assign project system

```{r}
kde_airbnb_june2019_private_bw_raster <- raster(gridded_kde_airbnb_june2019_private_bw)
projection(kde_airbnb_june2019_private_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb_june2019_home_bw_raster <- raster(gridded_kde_airbnb_june2019_home_bw)
projection(kde_airbnb_june2019_home_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb_june2019_share_bw_raster <- raster(gridded_kde_airbnb_june2019_share_bw)
projection(kde_airbnb_june2019_share_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb_july2021_private_bw_raster <- raster(gridded_kde_airbnb_july2021_private_bw)
projection(kde_airbnb_july2021_private_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb_july2021_home_bw_raster <- raster(gridded_kde_airbnb_july2021_home_bw)
projection(kde_airbnb_july2021_home_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb_july2021_share_bw_raster <- raster(gridded_kde_airbnb_july2021_share_bw)
projection(kde_airbnb_july2021_share_bw_raster) <- CRS("+init=EPSG:3414")

kde_airbnb_july2021_hotelroom_bw_raster <- raster(gridded_kde_airbnb_july2021_hotelroom_bw)
projection(kde_airbnb_july2021_hotelroom_bw_raster) <- CRS("+init=EPSG:3414")
```

#### Comparing Room Type and Year with KDE Map

##### **Private Room**

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")

airbnb_private_2019_map <- tm_basemap("OpenStreetMap") +
  tm_shape(kde_airbnb_june2019_private_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)

airbnb_private_2021_map <- tm_basemap("OpenStreetMap") +
  tm_shape(kde_airbnb_july2021_private_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)

tmap_arrange(airbnb_private_2019_map, airbnb_private_2021_map)

tmap_mode("plot")
```
Analysis: Chinatown has the most amount of private rooms in 2019. Chinatown density drops in 2021, however there are new areas such as areas near Geylang with a higher density.

##### **Entire Home/Apt**

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")

airbnb_home_2019_map <- tm_basemap("OpenStreetMap") +
  tm_shape(kde_airbnb_june2019_home_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)

airbnb_home_2021_map <- tm_basemap("OpenStreetMap") +
  tm_shape(kde_airbnb_july2021_home_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)

tmap_arrange(airbnb_home_2019_map, airbnb_home_2021_map)

tmap_mode("plot")
```

Analysis: There are significantly more entire home/apt in 2021 as compared to 2019

##### **Sharing Room**

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")

airbnb_share_2019_map <- tm_basemap("OpenStreetMap") +
  tm_shape(kde_airbnb_june2019_share_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)

airbnb_share_2021_map <- tm_basemap("OpenStreetMap") +
  tm_shape(kde_airbnb_july2021_share_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)

tmap_arrange(airbnb_share_2019_map, airbnb_share_2021_map)

tmap_mode("plot")
```

Analysis:  Clarke Quay is the area with the highest density for shared room type in 2019. However, in 2021, the shared rooms are more spread out.

##### **Hotel Rooms**

Plotting the raster layer on openstreetmap using interactive mode

```{r}
tmap_mode("view")

tm_basemap("OpenStreetMap") +
  tm_shape(kde_airbnb_july2021_hotelroom_bw_raster) + 
  tm_raster("v", palette = "Purples", alpha = 0.7)

tmap_mode("plot")
```

Analysis: This is a newly added room type in 2021, with most of the hotel rooms listed in Clarke Quay.

Overall: There were significant changes between 2019 and 2021, some density increased while some decreased. As all the room types are mainly seen in Chinatown, we will focus on that area instead,

#### Extracting study area and plotting target planning area

```{r}
outram = mpsz[mpsz@data$PLN_AREA_N == "OUTRAM",]
outram_sp = as(outram, "SpatialPolygons")
outram_owin = as(outram_sp, "owin")
airbnb_june2019_private_outram_ppp_sg = airbnb_june2019_private_ppp[sg_owin]
airbnb_june2019_home_outram_ppp_sg = airbnb_june2019_home_ppp_jit[sg_owin]
airbnb_june2019_share_outram_ppp_sg = airbnb_june2019_share_ppp_jit[sg_owin]
airbnb_july2021_private_outram_ppp_sg = airbnb_july2021_private_ppp[sg_owin]
airbnb_july2021_home_outram_ppp_sg = airbnb_july2021_home_ppp[sg_owin]
airbnb_july2021_share_outram_ppp_sg = airbnb_july2021_share_ppp[sg_owin]
airbnb_july2021_hotelroom_outram_ppp_sg = airbnb_july2021_hotelroom_ppp[sg_owin]
```

## Second-order Spatial Point Patterns Analysis

- Formulate the null hypothesis and alternative hypothesis and select the confidence level.

- Perform the test by using appropriate Second order spatial point patterns analysis technique.

- With reference to the analysis results, draw statistical conclusions.

### Second-order Multi-type Spatial Point Patterns Analysis

Checking the types of data in Airbnb June 2019

str() of Base R will be used to check the data type of childcare SpatialPointsDataFrame. This is necessary because the marked field must be in factor data type if its values are categorical.

```{r}
str(airbnb_june2019)
```
Making a factor data for room types 

```{r}
airbnb_june2019@data$room_type <- as.factor(airbnb_june2019@data$room_type)
airbnb_july2021@data$room_type <- as.factor(airbnb_july2021@data$room_type)
```

#### Converting the SpatialPointsDataFrame into ppp format

```{r}
airbnb_june2019_ppp <- as(airbnb_june2019, "ppp")
marks(airbnb_june2019_ppp) <- airbnb_june2019_ppp$marks$room_type
plot(airbnb_june2019_ppp)
```

There are 3 room types in 2019.

```{r}
airbnb_july2021_ppp <- as(airbnb_july2021, "ppp")
marks(airbnb_july2021_ppp) <- airbnb_july2021_ppp$marks$room_type
plot(airbnb_july2021_ppp)
```

There are 4 room types in 2019.

#### Examine summary statistics

```{r}
summary(airbnb_june2019_ppp)
```

```{r}
summary(airbnb_july2021_ppp)
```

#### Handling Duplicates

Applying jittering

```{r}
airbnb_june2019_ppp_jit <- rjitter(airbnb_june2019_ppp, retry=TRUE, nsim=1, drop=TRUE)
airbnb_july2021_ppp_jit <- rjitter(airbnb_july2021_ppp, retry=TRUE, nsim=1, drop=TRUE)
```

Checking for duplicates 

```{r}
any(duplicated(airbnb_june2019_ppp_jit))
```

```{r}
any(duplicated(airbnb_july2021_ppp_jit))
```

#### Extracting study area

```{r}
outram = mpsz[mpsz@data$PLN_AREA_N == "OUTRAM",]
plot(outram, main = "Outram")
```

```{r}
outram_sp = as(outram, "SpatialPolygons")
outram_owin = as(outram_sp, "owin")
```

Combining Airbnb points and the study area

```{r}
airbnb_june2019_outram_ppp = airbnb_june2019_ppp_jit[outram_owin]
airbnb_july2021_outram_ppp = airbnb_july2021_ppp_jit[outram_owin]
```

#### Analysing Marked Point Patterns

```{r}
plot(density(split(rescale(airbnb_june2019_outram_ppp, 1000))))
```

```{r}
intensity(rescale(airbnb_june2019_outram_ppp, 1000))
```

Private room has the highest density of 174 units per sqr kilometer, followed by Entire home/apt with a density of 116 units per sqr kilometer and lastly shared room with a density of 50 units per square kilometer

```{r}
plot(density(split(rescale(airbnb_july2021_outram_ppp, 1000))))
```

```{r}
intensity(rescale(airbnb_july2021_outram_ppp, 1000))
```

Private room has the highest density of 136 units per sqr kilometer, followed by Entire home/apt with a density of 87 units per sqr kilometer, next hotel room wth 52 units per sqr kilometer and lastly shared room with a density of 7 units per square kilometer

#### **Relationship of Private Room and Entire Home/Apt Airbnb in 2019**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbnb_june2019_peh_Lcross <- Lcross(airbnb_june2019_outram_ppp, i="Private room", j="Entire home/apt", correction='border')
plot(airbnb_june2019_peh_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```
Analysis: There are marked spatial points events that are not independent spatially from 0 to 150m since L(r) is above 0. Then the marked marked spatial point events are independent spatially as L(r) is below 0. Hypothesis needs to be tested to confirm observations.

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Private room and Entire home/apt in Airbnb 2019 are spatially independent.

H1= The distribution of Private room and Entire home/apt in Airbnb 2019 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_june2019_peh_Lcross.csr <- envelope(airbnb_june2019_outram_ppp, Lcross, i="Private room", j="Entire home/apt", correction='border', nsim=999)
```

```{r}
plot(airbnb_june2019_peh_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_june2019_peh_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: From the plot, L(r) observed line is below L(theo) line from 156m having a lower confidence envelope. The null hypothesis is rejected at 99% confidence interval, thus Private Rooms and Entire Home/Apt are not spatially independent.

#### **Relationship of Private Room and Shared Room Airbnb in 2019**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbn_june2019_Lcross <- Lcross(airbnb_june2019_outram_ppp, i="Private room", j="Shared room", correction='border')
plot(airbn_june2019_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```
Analysis: There are marked spatial points events that are not independent spatially from 0 to 150m since L(r) is above 0. Then the marked marked spatial point events are independent spatially as L(r) is below 0. Hypothesis needs to be tested to confirm observations.

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Private room and shared room in Airbnb 2019 are spatially independent.

H1= The distribution of Private room and shared room in Airbnb 2019 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_june2019_Lcross.csr <- envelope(airbnb_june2019_outram_ppp, Lcross, i="Private room", j="Shared room", correction='border', nsim=999)
```

```{r}
plot(airbnb_june2019_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_june2019_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: From the plot, L(r) observed line is below L(theo) line, having a lower confidence envelope. The null hypothesis is rejected at 99% confidence interval, thus Private Rooms and Shared Rooms are not spatially independent.

#### **Relationship of Entire home/apt and Shared Room Airbnb in 2019**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbnb_june2019_ehsr_Lcross <- Lcross(airbnb_june2019_outram_ppp, i="Entire home/apt", j="Shared room", correction='border')
plot(airbnb_june2019_ehsr_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```
Analysis: There are marked spatial points events that are not independent spatially from 0 to 150m since L(r) is above 0. Then the marked marked spatial point events are independent spatially as L(r) is below 0. Hypothesis needs to be tested to confirm observations.

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Entire home/apt and shared room in Airbnb 2019 are spatially independent.

H1= The distribution of Entire home/apt and shared room in Airbnb 2019 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_june2019_ehsr_Lcross.csr <- envelope(airbnb_june2019_outram_ppp, Lcross, i="Entire home/apt", j="Shared room", correction='border', nsim=999)
```

```{r}
plot(airbnb_june2019_ehsr_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_june2019_ehsr_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

Analysis: From the plot, L(r) observed line is below L(theo) line, having a lower confidence envelope. The null hypothesis is not rejected at 99% confidence interval, thus Private Rooms and Shared Rooms are spatially independent.

#### **Relationship of Private Room and Entire Home/Apt Airbnb in 2021**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbnb_july2021_peh_Lcross <- Lcross(airbnb_july2021_outram_ppp, i="Private room", j="Entire home/apt", correction='border')
plot(airbnb_july2021_peh_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: There are marked spatial points events that are not independent spatially from 0 to 150m since L(r) is above 0. Then the marked marked spatial point events are independent spatially as L(r) is below 0. Hypothesis needs to be tested to confirm observations.

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Private rooms and Entire home/apt in Airbnb 2021 are spatially independent.

H1= The distribution of Private rooms and Entire home/apt in Airbnb 2021 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_july2021_peh_Lcross.csr <- envelope(airbnb_july2021_outram_ppp, Lcross, i="Private room", j="Entire home/apt", correction='border', nsim=999)
```

```{r}
plot(airbnb_july2021_peh_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_july2021_peh_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```
#### **Relationship of Private Room and Shared Room Airbnb in 2021**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbnb_july2021_Lcross <- Lcross(airbnb_july2021_outram_ppp, i="Private room", j="Shared room", correction='border')
plot(airbnb_july2021_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Private rooms and shared room in Airbnb 2021 are spatially independent.

H1= The distribution of Private rooms and shared room in Airbnb 2021 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_july2021_Lcross.csr <- envelope(airbnb_july2021_outram_ppp, Lcross, i="Private room", j="Shared room", correction='border', nsim=999)
```

```{r}
plot(airbnb_july2021_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_july2021_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

#### **Relationship of Private Room and Hotel Room Airbnb in 2021**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbnb_july2021_phr_Lcross <- Lcross(airbnb_july2021_outram_ppp, i="Private room", j="Hotel room", correction='border')
plot(airbnb_july2021_phr_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

Analysis: There are marked spatial points events that are not independent spatially from 0 to 150m since L(r) is above 0. Then the marked marked spatial point events are independent spatially as L(r) is below 0. Hypothesis needs to be tested to confirm observations.

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Private rooms and hotel rooms in Airbnb 2021 are spatially independent.

H1= The distribution of Private rooms and hotel rooms in Airbnb 2021 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_july2021_phr_Lcross.csr <- envelope(airbnb_july2021_outram_ppp, Lcross, i="Private room", j="Hotel room", correction='border', nsim=999)
```

```{r}
plot(airbnb_july2021_phr_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_july2021_phr_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

#### **Relationship of Entire home/apt and Shared Room Airbnb in 2021**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbnb_july2021_ehsr_Lcross <- Lcross(airbnb_july2021_outram_ppp, i="Entire home/apt", j="Shared room", correction='border')
plot(airbnb_july2021_ehsr_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Entire home/apt and shared room in Airbnb 2021 are spatially independent.

H1= The distribution of Entire home/apt and shared room in Airbnb 2021 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_july2021_ehsr_Lcross.csr <- envelope(airbnb_july2021_outram_ppp, Lcross, i="Entire home/apt", j="Shared room", correction='border', nsim=999)
```

```{r}
plot(airbnb_july2021_ehsr_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_july2021_ehsr_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

#### **Relationship of Entire home/apt and Hotel Room in 2021**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbnb_july2021_ehhr_Lcross <- Lcross(airbnb_july2021_outram_ppp, i="Entire home/apt", j="Hotel room", correction='border')
plot(airbnb_july2021_ehhr_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Entire home/apt and hotel room in Airbnb 2021 are spatially independent.

H1= The distribution of Entire home/apt and hotel room in Airbnb 2021 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_july2021_ehhr_Lcross.csr <- envelope(airbnb_july2021_outram_ppp, Lcross, i="Entire home/apt", j="Hotel room", correction='border', nsim=999)
```

```{r}
plot(airbnb_july2021_ehhr_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_july2021_ehhr_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

#### **Relationship of Shared room and Hotel Room in 2021**

#### Second-order Multi-tpye Point Patterns Analysis: Cross L-Function

```{r}
airbnb_july2021_srhr_Lcross <- Lcross(airbnb_july2021_outram_ppp, i="Shared room", j="Hotel room", correction='border')
plot(airbnb_july2021_srhr_Lcross, . -r ~ r, xlab = "distance(m)", xlim=c(0, 500))
```

#### Performing CSR testing on the Cross L-Function

PERFORMING COMPLETE SPATIAL RANDOMNESS TEST

To confirm the observed spatial patterns above, a hypothesis test will be conducted. The hypothesis and test are as follows:

Ho = The distribution of Shared room and hotel room in Airbnb 2021 are spatially independent.

H1= The distribution of Shared room and hotel room in Airbnb 2021 are not spatially independent.

The null hypothesis will be rejected if p-value is smaller than alpha value of 0.001. (99% confidence level)

```{r}
airbnb_july2021_srhr_Lcross.csr <- envelope(airbnb_july2021_outram_ppp, Lcross, i="Shared room", j="Hotel room", correction='border', nsim=999)
```

```{r}
plot(airbnb_july2021_srhr_Lcross.csr, . -r ~ r, xlab="distance(m)", xlim=c(0,500))
```

```{r}
title <- "Cross L function"
Lcsr_df <- as.data.frame(airbnb_july2021_srhr_Lcross.csr)
colour=c("#0D657D","#ee770d","#D3D3D3")
csr_plot <- ggplot(Lcsr_df, aes(r, obs-r))+
  # plot observed value
  geom_line(colour=c("#4d4d4d"))+
  geom_line(aes(r,theo-r), colour="red", linetype = "dashed")+
  # plot simulation envelopes
  geom_ribbon(aes(ymin=lo-r,ymax=hi-r),alpha=0.1, colour=c("#91bfdb")) +
  xlab("Distance r (m)") +
  ylab("L(r)-r") +
  geom_rug(data=Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,], sides="b", colour=colour[1])  +
  geom_rug(data=Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,], sides="b", colour=colour[2]) +
  geom_rug(data=Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,], sides="b", color=colour[3]) +
  theme_tufte()+
  ggtitle(title)
text1<-"Significant clustering"
text2<-"Significant segregation"
text3<-"Not significant clustering/segregation"
# the below conditional statement is required to ensure that the labels (text1/2/3) are assigned to the correct traces
if (nrow(Lcsr_df[Lcsr_df$obs > Lcsr_df$hi,])==0){ 
  if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text3, traces = 4) %>%
      rangeslider() 
  }else if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){ 
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      rangeslider() 
  }else {
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text2, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider() 
  }
} else if (nrow(Lcsr_df[Lcsr_df$obs < Lcsr_df$lo,])==0){
  if (nrow(Lcsr_df[Lcsr_df$obs >= Lcsr_df$lo & Lcsr_df$obs <= Lcsr_df$hi,])==0){
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      rangeslider() 
  } else{
    ggplotly(csr_plot, dynamicTicks=T) %>%
      style(text = text1, traces = 4) %>%
      style(text = text3, traces = 5) %>%
      rangeslider()
  }
} else{
  ggplotly(csr_plot, dynamicTicks=T) %>%
    style(text = text1, traces = 4) %>%
    style(text = text2, traces = 5) %>%
    style(text = text3, traces = 6) %>%
    rangeslider()
  }
```

